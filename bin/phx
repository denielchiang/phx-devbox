#!/bin/bash
set -e

##########################################################
# Function Definitions - All functions must be defined before use
##########################################################

# Show help information
show_help() {
    echo "Usage: phx [options] [commands]"
    echo ""
    echo "Options:"
    echo "  -v, --phx, --phoenix-version   Specify Phoenix framework version"
    echo "  -e, --ex, --elixir-version    Specify Elixir version (default: latest)"
    echo "  -o, --erl, --erlang-version   Specify Erlang version (default: latest)"
    echo "  -p, --path                    Specify path for project creation"
    echo "  -h, --help                    Show this help message"
    echo ""
    echo "Command examples:"
    echo "  phx new my_app        # Create a new Phoenix application"
    echo "  phx new my_app --live # Create a new Phoenix LiveView application"
    echo "  phx --path /path/to/my_project new my_app  # Create a new application in a specific path"
    echo "  phx deps.get          # Get dependencies"
    echo "  phx phx.server        # Start Phoenix server"
    echo "  phx iex               # Start IEx shell"
    echo "  phx iex.phx           # Start IEx and load Phoenix application (iex -S mix phx.server)"
    echo "  phx test               # Run tests"
    echo "  phx ecto.create       # Create database"
    echo "  phx ecto.migrate      # Run migrations"
    echo "  phx ecto.setup        # Initialize database (create, load defaults)"
    echo "  phx ecto.reset        # Reset database (drop and recreate)"
    echo "  phx routes             # Show all routes"
    echo "  phx bash               # Enter container's bash"
    echo "  phx update-versions    # Update .tool-versions file"
    echo "  phx debug-path         # Debug configuration file paths"
    echo ""
    echo "All mix and iex commands can be used directly"
}

# Check Docker Compose and set the correct command
check_docker_compose() {
    local docker_compose_found=false
    
    if command -v docker-compose &> /dev/null; then
        # Traditional docker-compose command
        docker_compose_cmd="docker-compose"
        docker_compose_found=true
    elif command -v docker &> /dev/null && docker compose version &> /dev/null; then
        # New docker compose subcommand
        docker_compose_cmd="docker compose"
        docker_compose_found=true
    fi
    
    if [ "$docker_compose_found" = false ]; then
        echo "Error: Docker Compose not found. Please make sure Docker Desktop or Docker Engine is installed with Docker Compose functionality."
        exit 1
    fi
    
    # Check if you have permission to run Docker
    if ! docker info &>/dev/null; then
        echo "Warning: Unable to connect to Docker. Please make sure Docker is running and you have permission to execute Docker commands."
        echo "If you are not in the docker group, you may need to run:"
        echo "  sudo usermod -aG docker $(whoami) && newgrp docker"
        exit 1
    fi
    
    echo "Using Docker Compose command: $docker_compose_cmd"
}

# Get current user's UID and GID
setup_user_permissions() {
    # Get user's UID and GID
    export CURRENT_UID=$(id -u)
    export CURRENT_GID=$(id -g)
    
    echo "Container will use user ID: $CURRENT_UID and group ID: $CURRENT_GID"
}

# Update .tool-versions file
update_tool_versions() {
    local target_dir="$1"
    
    # Create .tool-versions file
    cat > "$target_dir/.tool-versions" << EOF
erlang $ERLANG_VERSION
elixir $ELIXIR_VERSION
EOF
    
    # Show the file contents for confirmation
    echo "Created .tool-versions file with the following content:"
    
    echo ".tool-versions file updated:"
    cat "$target_dir/.tool-versions"
}

# Prepare docker-compose.yml file to avoid Docker mount issues
prepare_docker_compose() {
    # Create temporary directory
    local tmp_dir=$(mktemp -d)
    
    # Copy modified docker-compose.yml to temporary directory
    # Remove ".:/app" mount to avoid Docker mounting Homebrew directory
    cat "$SCRIPT_DIR/docker-compose.yml" | sed 's|- \.:/app.*||g' > "$tmp_dir/docker-compose.yml"
    
    # Return temporary directory path
    echo "$tmp_dir"
}

# Run command with safe docker-compose configuration
run_with_safe_compose() {
    local command_args=("$@")
    
    # Prepare safe docker-compose.yml
    local tmp_dir=$(prepare_docker_compose)
    
    # Run command
    $docker_compose_cmd -f "$tmp_dir/docker-compose.yml" "${command_args[@]}"
    
    # Save exit status
    local exit_status=$?
    
    # Clean up temporary directory
    rm -rf "$tmp_dir"
    
    # Return original command's exit status
    return $exit_status
}

##########################################################
# Main Program Entry
##########################################################

# Define global variables
docker_compose_cmd=""
SCRIPT_DIR=""
PROJECT_PATH="$(pwd)"

# Default values
ELIXIR_VERSION="latest"
ERLANG_VERSION="latest"
PHOENIX_VERSION=""

# Check if Docker and Docker Compose are available
check_docker_compose

# Process command-line arguments
while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--phx|--phoenix-version)
            PHOENIX_VERSION="$2"
            shift 2
            ;;
        -e|--ex|--elixir-version)
            ELIXIR_VERSION="$2"
            shift 2
            ;;
        -o|--erl|--erlang-version)
            ERLANG_VERSION="$2"
            shift 2
            ;;
        -p|--path)
            # Resolve relative path to absolute
            TEMP_PATH="$2"
            if [[ "$TEMP_PATH" = /* ]]; then
                PROJECT_PATH="$TEMP_PATH"
            else
                PROJECT_PATH="$(pwd)/$TEMP_PATH"
            fi
            shift 2
            ;;
        debug-path)
            # Debug command to show path information
            echo "===== PHX Path Debug Information ====="
            echo "Current script location: $(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
            echo "Current working directory: $(pwd)"
            # Check possible locations for docker-compose.yml
            echo "Checking possible config file locations:"
            script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
            echo "  - $script_dir ($([ -d "$script_dir" ] && echo 'directory exists' || echo 'directory does not exist'))"
            echo "    * docker-compose.yml $([ -f "$script_dir/docker-compose.yml" ] && echo 'exists' || echo 'does not exist')"
            parent_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")/../" 2>/dev/null && pwd)
            echo "  - $parent_dir ($([ -d "$parent_dir" ] && echo 'directory exists' || echo 'directory does not exist'))"
            echo "    * docker-compose.yml $([ -f "$parent_dir/docker-compose.yml" ] && echo 'exists' || echo 'does not exist')"
            homebrew_cellar_dir_arm="/opt/homebrew/Cellar/phx"
            echo "  - $homebrew_cellar_dir_arm ($([ -d "$homebrew_cellar_dir_arm" ] && echo 'directory exists' || echo 'directory does not exist'))"
            echo "    * docker-compose.yml $([ -f "$homebrew_cellar_dir_arm/docker-compose.yml" ] && echo 'exists' || echo 'does not exist')"
            homebrew_cellar_dir_intel="/usr/local/Cellar/phx"
            echo "  - $homebrew_cellar_dir_intel ($([ -d "$homebrew_cellar_dir_intel" ] && echo 'directory exists' || echo 'directory does not exist'))"
            homebrew_etc_dir_arm="/opt/homebrew/etc/phx"
            echo "  - $homebrew_etc_dir_arm ($([ -d "$homebrew_etc_dir_arm" ] && echo 'directory exists' || echo 'directory does not exist'))"
            homebrew_etc_dir_intel="/usr/local/etc/phx"
            echo "  - $homebrew_etc_dir_intel ($([ -d "$homebrew_etc_dir_intel" ] && echo 'directory exists' || echo 'directory does not exist'))"
            if [ -d "$homebrew_cellar_dir_arm" ]; then
                echo "Checking all versions under $homebrew_cellar_dir_arm:"
                for version_dir in "$homebrew_cellar_dir_arm"/*; do
                    echo "  - $version_dir ($([ -d "$version_dir" ] && echo 'directory exists' || echo 'directory does not exist'))"
                    echo "    * docker-compose.yml $([ -f "$version_dir/docker-compose.yml" ] && echo 'exists' || echo 'does not exist')"
                done
            fi
            if [ -d "$homebrew_cellar_dir_intel" ]; then
                echo "Checking all versions under $homebrew_cellar_dir_intel:"
                for version_dir in "$homebrew_cellar_dir_intel"/*; do
                    echo "  - $version_dir ($([ -d "$version_dir" ] && echo 'directory exists' || echo 'directory does not exist'))"
                    echo "    * docker-compose.yml $([ -f "$version_dir/docker-compose.yml" ] && echo 'exists' || echo 'does not exist')"
                done
            fi
            echo "Docker compose file check: $(ls -la $SCRIPT_DIR/docker-compose.yml 2>&1)"
            
            # Exit after showing debug info
            exit 0
            ;;
        update-versions)
            # Update .tool-versions file in current directory or specified path
            echo "Exporting environment variables for .tool-versions update"
            
            # Export environment variables
            export ELIXIR_VERSION
            export ERLANG_VERSION
            export PHOENIX_VERSION
            
            # Use current directory
            update_tool_versions "."
            exit 0
            ;;
        *)
            break
            ;;
    esac
done

# Get absolute path of script
INITIAL_SCRIPT_PATH=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)

# Set up possible configuration file paths
CONFIG_PATHS=(
    "$INITIAL_SCRIPT_PATH"                # 1. Current script directory
    "$INITIAL_SCRIPT_PATH/.."             # 2. Parent directory of current script
)

# Check if this is a Homebrew installation
if [[ "$INITIAL_SCRIPT_PATH" == "/opt/homebrew/bin" || "$INITIAL_SCRIPT_PATH" == "/usr/local/bin" ]]; then
    echo "Detected Homebrew installation, searching for configuration files..."
    
    # Determine Homebrew prefix based on architecture
    if [[ "$INITIAL_SCRIPT_PATH" == "/opt/homebrew/bin" ]]; then
        BREW_PREFIX="/opt/homebrew"
    else
        BREW_PREFIX="/usr/local"
    fi
    
    # Add standard Homebrew locations
    CONFIG_PATHS+=(
        "$BREW_PREFIX/etc/phx"                # 3. Standard Homebrew config directory
        "$BREW_PREFIX/opt/phx"                # 4. Homebrew opt directory
    )
    
    # Add all possible Cellar version directories
    if [[ -d "$BREW_PREFIX/Cellar/phx" ]]; then
        for version_dir in "$BREW_PREFIX/Cellar/phx"/*; do
            if [[ -d "$version_dir" ]]; then
                CONFIG_PATHS+=("$version_dir")    # 5. Specific version Cellar directory
            fi
        done
    fi
elif [[ "$INITIAL_SCRIPT_PATH" == "/opt/homebrew/Cellar/phx"* ]] || [[ "$INITIAL_SCRIPT_PATH" == "/usr/local/Cellar/phx"* ]]; then
    # For direct Cellar installation
    # First determine if we're using Apple Silicon (/opt/homebrew) or Intel (/usr/local)
    if [[ "$INITIAL_SCRIPT_PATH" == "/opt/homebrew/"* ]]; then
        BREW_PREFIX="/opt/homebrew"
    else
        BREW_PREFIX="/usr/local"
    fi
    
    # Add the Cellar package directory
    # Get the relative path to the phx binary within the Cellar structure
    REL_PATH=${INITIAL_SCRIPT_PATH#$BREW_PREFIX/Cellar/}
    # Extract just the package name and version (should be something like "phx/0.1.3")
    PKG_PATH=$(echo "$REL_PATH" | cut -d/ -f1-2)
    # Add this path to our search list
    CONFIG_PATHS+=("$BREW_PREFIX/Cellar/$PKG_PATH")
fi

# Search for docker-compose.yml file
SCRIPT_DIR=""
FOUND_CONFIG=false

for path in "${CONFIG_PATHS[@]}"; do
    if [[ -f "$path/docker-compose.yml" ]]; then
        SCRIPT_DIR="$path"
        FOUND_CONFIG=true
        echo "Found configuration file: $SCRIPT_DIR/docker-compose.yml"
        break
    fi
done

if [[ "$FOUND_CONFIG" != true ]]; then
    echo "Error: Unable to find docker-compose.yml configuration file!"
    echo "Checked the following paths:"
    for path in "${CONFIG_PATHS[@]}"; do
        echo "  - $path/docker-compose.yml"
    done
    exit 1
fi

# Check if it's a command to create a new project
if [[ "$1" == "new" ]]; then
    # Get application name and other options from parameters
    APP_NAME=$2
    shift 2

    # If Phoenix version is not specified, prompt user to input
    if [[ -z "$PHOENIX_VERSION" ]]; then
        echo "Please enter the Phoenix framework version to use (e.g.: 1.7.10):"
        read -r PHOENIX_VERSION
        
        if [[ -z "$PHOENIX_VERSION" ]]; then
            echo "Error: Phoenix framework version must be specified"
            exit 1
        fi
    fi

    # Setup user permissions
    setup_user_permissions

    # Export environment variables
    export PHOENIX_VERSION
    export ELIXIR_VERSION
    export ERLANG_VERSION

    # Build Docker image from script directory
    echo "Building Phoenix $PHOENIX_VERSION environment..."
    echo "Using Elixir $ELIXIR_VERSION and Erlang $ERLANG_VERSION (if 'latest' is specified, the newest version will be used)"
    run_with_safe_compose build

    # Target path permission check
    if [ ! -d "$PROJECT_PATH" ]; then
        if ! mkdir -p "$PROJECT_PATH" 2>/dev/null; then
            echo "Error: Cannot create directory '$PROJECT_PATH'. Please ensure you have sufficient permissions."
            exit 1
        fi
    elif [ ! -w "$PROJECT_PATH" ]; then
        echo "Error: You don't have write permission for '$PROJECT_PATH'. Please use another path or change permissions."
        exit 1
    fi
    
    # Switch to specified directory
    cd "$PROJECT_PATH" || { echo "Error: Unable to switch to '$PROJECT_PATH'"; exit 1; }

    # Ensure directory doesn't exist, otherwise mix phx.new will fail
    if [[ -d "$APP_NAME" ]]; then
        echo "Error: Directory '$APP_NAME' already exists"
        exit 1
    fi

    # Execute mix phx.new command
    echo "Creating new Phoenix application '$APP_NAME'..."
    
    # Use safe docker-compose handling
    run_with_safe_compose run --rm -t -v "$PROJECT_PATH:/app" phoenix bash -c "echo Y | mix phx.new $APP_NAME $*"
    
    # Check if command executed successfully
    if [ $? -ne 0 ]; then
        echo "Error: Unable to create Phoenix project, possibly due to Docker mount issues."
        echo "Please ensure the current directory ($PROJECT_PATH) is shared with Docker."
        echo "You can configure shared paths in Docker Desktop -> Preferences... -> Resources -> File Sharing."
        echo "See https://docs.docker.com/desktop/settings/mac/#file-sharing for details."
        exit 1
    fi

    # Move generated files to current directory
    echo "Organizing project files..."
    cd "$PROJECT_PATH"
    mv $APP_NAME/* .
    mv $APP_NAME/.* . 2>/dev/null || true
    rmdir $APP_NAME

    # Modify the generated database configuration to use environment variables
    echo "Configuring database connection..."
    sed -i '' 's/hostname: "localhost"/hostname: System.get_env("DATABASE_HOST", "localhost")/' "$PROJECT_PATH/config/dev.exs"
    sed -i '' 's/username: "postgres"/username: System.get_env("DATABASE_USER", "postgres")/' "$PROJECT_PATH/config/dev.exs"
    sed -i '' 's/password: "postgres"/password: System.get_env("DATABASE_PASSWORD", "postgres")/' "$PROJECT_PATH/config/dev.exs"
    
    # Ensure live_reload is enabled in configuration
    if ! grep -q "live_reload:" "$PROJECT_PATH/config/dev.exs"; then
        echo "Warning: live_reload configuration not found in dev.exs, may need to be added manually."
    fi
    
    # Create .tool-versions file
    echo "Creating .tool-versions file..."
    update_tool_versions "$PROJECT_PATH"
    
    echo "Phoenix application '$APP_NAME' created successfully!"
    echo "To start your Phoenix server:"
    echo "  cd $APP_NAME"
    echo "  phx deps.get"
    echo "  phx ecto.create"
    echo "  phx phx.server"
else
    # Check if no command was provided
    if [[ $# -eq 0 ]]; then
        show_help
        exit 0
    fi
    
    # Setup user permissions
    setup_user_permissions

    # Export environment variables
    export PHOENIX_VERSION
    export ELIXIR_VERSION
    export ERLANG_VERSION

    # Determine if we can use the project directory directly
    # If a default path is provided, it will be mapped to /app in the container
    if [[ "$1" == "bash" ]]; then
        # Enter container bash directly
        run_with_safe_compose run --rm -v "$PROJECT_PATH:/app" -w /app phoenix bash
    elif [[ "$1" == "iex" ]] && [[ "$#" == 1 ]]; then
        # Start IEx shell
        run_with_safe_compose run --rm -v "$PROJECT_PATH:/app" -w /app phoenix iex
    elif [[ "$1" == "iex.phx" ]] || [[ "$1" == "iex:phx" ]]; then
        # Start IEx and load Phoenix application
        run_with_safe_compose run --rm --service-ports -v "$PROJECT_PATH:/app" -w /app -e DATABASE_HOST=host.docker.internal phoenix iex -S mix phx.server
    else
        # Check if it's an iex command
        if [[ "$1" == "iex" ]] && [[ "$#" -gt 1 ]]; then
            # Execute iex directly but preserve additional options
            run_with_safe_compose run --rm -v "$PROJECT_PATH:/app" -w /app phoenix "$@"
        elif [[ "$1" == "phx.server" ]]; then
            # Start Phoenix server
            run_with_safe_compose run --rm --service-ports -v "$PROJECT_PATH:/app" -w /app -e DATABASE_HOST=host.docker.internal phoenix mix phx.server
        else
            # Execute all other mix commands
            run_with_safe_compose run --rm -v "$PROJECT_PATH:/app" -w /app -e DATABASE_HOST=host.docker.internal phoenix mix "$@"
        fi
    fi
fi